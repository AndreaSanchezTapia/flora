{
    "contents" : "#' Get plant taxonomical and distribution data\n#' \n#' This function collects taxonomic information and distribution from the\n#' Brazilian Flora Checklist. Synonyms and misspelled names are resolved \n#' automatically. Results can be combined with life form, habitat, vernacular\n#' name, and occurrence data.\n#' \n#' @param taxa a character vector containing one or more taxa, without authors \n#'   see \\code{\\link{remove.authors}} if you have a list with authorities\n#' @param replace.synonyms should the function automatically replace synonyms?\n#' @param suggest.names should the function try to correct misspelled names?\n#' @param life.form include the life form of the taxon?\n#' @param habitat include the habitat of the taxon?\n#' @param vernacular include vernacular names and localities?\n#' @param states include occurrence data?\n#' @param establishment include the establishment type (native, cultivated or \n#'   naturalized)?\n#' @param drop NULL or character vector with names of columns with taxonomic\n#'   information to be removed from the returned data frame. Available names: \n#'   \"id\", \"scientific.name\", \"accepted.name\", \"family\", \"genus\",\n#'   \"specific.epiteth\", \"infra.epiteth\", \"taxon.rank\", \"authorship\",\n#'   \"taxon.status\", \"name.status\", and \"search.str\".\n#' @details The returned data frame will contain a variable number of rows and \n#'   columns depending on how the function was called. For instance, since there\n#'   might be more than one vernacular name for each taxon, some rows\n#'   will be duplicated if \\code{vernacular} is set to \\code{TRUE}. All misspelled taxa\n#'   are automatically corrected if the function can come up with a reasonable\n#'   guess for the name.\n#' @return a data frame\n#' @export\n#' @examples \n#' data(plants)\n#' get.taxa(plants)\n#' get.taxa(plants, life.form = TRUE, establishment = TRUE)\nget.taxa <- function (taxa, replace.synonyms = TRUE, suggest.names = TRUE, \n                      life.form = FALSE, habitat = FALSE, vernacular = FALSE, states = FALSE, \n                      establishment = FALSE, drop = c(\"authorship\", \"genus\", \"specific.epiteth\", \n                                                      \"infra.epiteth\", \"name.status\")) \n{\n  taxa <- trim(taxa)\n  taxa <- taxa[nzchar(taxa)]\n  if (length(taxa) == 0L) \n    stop(\"No valid names provided.\")\n  original.search <- taxa\n  ncol.taxa <- ncol(all.taxa)\n  res <- data.frame(matrix(vector(), length(taxa), ncol.taxa + \n                             1, dimnames = list(c(), c(names(all.taxa), \"notes\"))), \n                    stringsAsFactors = FALSE)\n  minus.notes <- seq_len(ncol.taxa)\n  index <- 0\n  for (taxon in taxa) {\n    notes <- NULL\n    index <- index + 1\n    taxon <- fixCase(taxon)\n    uncertain <- regmatches(taxon, regexpr(\"[a|c]f+\\\\.\", \n                                           taxon))\n    if (length(uncertain) != 0L) {\n      taxon <- gsub(\"\\\\s[a|c]f+\\\\.\", \"\", taxon)\n    }\n    ident <- regmatches(taxon, regexpr(\"\\\\s+sp\\\\.+\\\\w*\", \n                                       taxon))\n    if (length(ident) != 0L) {\n      taxon <- unlist(strsplit(taxon, \" \"))[1]\n    }\n    found <- length(with(all.taxa, {\n      which(search.str == taxon)\n    })) > 0L\n    if (!found) {\n      if (suggest.names) {\n        taxon <- suggest.names(taxon)\n      }\n      else {\n        res[index, \"notes\"] <- \"not found\"\n        next\n      }\n      if (is.na(taxon)) {\n        res[index, \"notes\"] <- \"not found\"\n        next\n      }\n      else {\n        notes <- \"was misspelled\"\n      }\n    }\n    accepted <- all.taxa[with(all.taxa, {\n      which(search.str == taxon & taxon.status == \"accepted\")\n    }), ]\n    if (nrow(accepted) > 0) {\n      if (nrow(accepted) == 1L) {\n        res[index, minus.notes] <- accepted\n      }\n      else {\n        notes <- c(notes, \"check +1 accepted\")\n      }\n      res[index, \"notes\"] <- paste(notes, collapse = \"|\")\n      next\n    }\n    synonym <- all.taxa[with(all.taxa, {\n      which(search.str == taxon & taxon.status == \"synonym\")\n    }), ]\n    nrow.synonym <- nrow(synonym)\n    if (nrow.synonym > 0L) {\n      if (replace.synonyms) {\n        accepted <- relationships[with(relationships, \n{\n  which(related.id %in% synonym$id)\n}), ]\nnrow.accepted <- nrow(accepted)\nif (nrow.accepted == 0L) {\n  if (nrow.synonym == 1L) {\n    notes <- c(notes, \"check no accepted name\")\n    res[index, minus.notes] <- synonym\n  }\n  if (nrow.synonym > 1L) {\n    notes <- c(notes, \"check no accepted +1 synonyms\")\n  }\n}\nif (nrow.accepted == 1L) {\n  accepted.info <- all.taxa[with(all.taxa, {\n    which(id %in% accepted$id)\n  }), ]\n  nrow.accepted.info <- nrow(accepted.info)\n  if (nrow.accepted.info == 0L) {\n    notes <- c(notes, \"check no accepted name\")\n    res[index, minus.notes] <- synonym\n  }\n  if (nrow.accepted.info == 1L) {\n    notes <- c(notes, \"replaced synonym\")\n    res[index, minus.notes] <- accepted.info\n  }\n  if (nrow.accepted.info > 1L) {\n    notes <- c(notes, \"check +1 accepted\")\n    res[index, minus.notes] <- synonym\n  }\n}\nif (nrow.accepted > 1L) {\n  notes <- c(notes, \"check +1 accepted entries\")\n  res[index, minus.notes] <- synonym\n}\n      }\nelse {\n  if (nrow(synonym) == 1L) {\n    res[index, minus.notes] <- synonym\n  }\n  else {\n    notes <- c(notes, \"check +1 entries\")\n  }\n}\nres[index, \"notes\"] <- paste(notes, collapse = \"|\")\nnext\n    }\n  }\nif (is.null(drop)) {\n  res <- data.frame(res, original.search, stringsAsFactors = FALSE)\n}\nelse {\n  res <- data.frame(res[, !names(res) %in% drop], original.search, \n                    stringsAsFactors = FALSE)\n}\nif (life.form) {\n  res <- merge(res, species.profiles[, c(\"id\", \"life.form\")], \n               by = \"id\", all.x = TRUE)\n}\nif (habitat) {\n  res <- merge(res, species.profiles[, c(\"id\", \"habitat\")], \n               by = \"id\", all.x = TRUE)\n}\nif (vernacular) {\n  res <- merge(res, vernacular.names[, c(\"id\", \"vernacular.name\", \n                                         \"locality\")], by = \"id\", all.x = TRUE)\n}\nif (states) {\n  res <- merge(res, distribution[, c(\"id\", \"occurrence\")], \n               by = \"id\", all.x = TRUE)\n}\nif (establishment) {\n  res <- merge(res, distribution[, c(\"id\", \"establishment\")], \n               by = \"id\", all.x = TRUE)\n}\nres\n}",
    "created" : 1403717854074.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2788467708",
    "id" : "2B5E8806",
    "lastKnownWriteTime" : 1403717889,
    "path" : "~/Documents/flora/R/get.taxa.R",
    "project_path" : "R/get.taxa.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}